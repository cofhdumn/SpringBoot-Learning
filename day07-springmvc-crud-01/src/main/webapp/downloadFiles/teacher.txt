一、SpringMVC的案例(前后端分离)
1. 运行前端项目:
	1.1 使用VSCode打开前端项目
	1.2 执行命令: npm i
	1.3 执行命令: npm run dev

2. 分析前端代码:
	2.1 后端的统一的请求路径: http://localhost:8080/rest
	2.2 查询所有:
		2.2.1 请求路径: http://localhost:8080/rest/schedule
		2.2.2 请求方式: GET
		2.2.3 响应数据的格式: 
			(1) code
			(2) flag
			(3) data:
				JSON数组，数组中每一个JSON都有三个键值对:id、title、completed
				
	2.3 添加:
		2.3.1 请求路径: http://localhost:8080/rest/schedule
		2.3.2 请求方式: POST
		2.3.3 请求参数: JSON,里面包含俩键值对:title、completed
		2.3.4 响应数据:
			(1) code
			(2) flag
			(3) data
	
	2.4 修改
		2.4.1 请求路径: http://localhost:8080/rest/schedule
		2.4.2 请求方式: PUT
		2.4.3 请求参数: JSON,里面包含仨键值对:id、title、completed
		2.4.4 响应数据:
			(1) code
			(2) flag
			(3) data
			
	2.5 删除
		2.5.1 请求路径: http://localhost:8080/rest/schedule/{id}
		2.5.2 请求方式: DELETE
		2.5.3 请求参数: 路径参数
		2.5.4 响应数据:
			(1) code
			(2) flag
			(3) data

3. 创建表

4. 初始化项目
	4.1 创建项目
	4.2 引入依赖:
		(1) 公共基础层:
			(1.1) junit
			(1.2) spring-test
			(1.3) logback
			(1.4) lombok
		(2) 持久层:
			(2.1) mysql驱动
			(2.2) druid
			(2.3) jdbcTemplate
			(2.4) spring-jdbc
		(3) 业务层:
			(3.1) spring-context
			(3.2) aspectj
		(4) 表现层:
			(4.1) servlet
			(4.2) spring-webmvc
			(4.3) jackson
			(4.4) 如果需要数据校验:hibernate-validator
	4.3 公共技术
		(1) 实体类:Schedule
		(2) 封装响应结果的类:Result
	4.4 持久层
		(1) 持久层的接口
		(2) 持久层的实现类
		(3) 持久层的spring配置
		(4) 使用Junit测试持久层
	4.5 业务层
		(1) 业务层的接口
		(2) 业务层的实现类
		(3) 业务层的spring配置
		(4) 声明式事务
		(5) aop
	4.6 表现层
		(1) 配置DispatcherServlet前端控制器
		(2) 添加表形层spring配置
		(3) 创建表现层的类
		(4) 部署项目

5. 解决跨域问题:
	5.1 方式一: 使用@CrossOrigin注解允许跨域,它只能够对添加了该注解的方法或者类生效
	5.2 方式二: 在xml配置文件中进行全局配置
	
二、全局的异常处理器
1. 期望效果:后端出现异常，那么就向前端响应JSON
{
	code:500,
	flag:false,
	data:null
}

2. 目前的现状:后端出现异常，那么就向前端响应500页面
3. 怎么解决? 使用全局异常处理器
	3.1 创建全局异常处理器类，类上添加@RestControllerAdvice注解

三、SpringMVC的拦截器Interceptor
1. 拦截器与过滤器有什么相同点和不同点?
	1.1 相同点:
		(1) 拦截:指定哪些请求需要经过拦截器/过滤器
		(2) 过滤:编写一些逻辑对请求进行处理,例如校验是否已登录、例如过滤非法字符
		(3) 放行:让请求达到目的地
	1.2 不同点:
		(1) 过滤器只有一个doFilter()方法，在请求被处理之前对请求进行过滤;但是拦截器有多个方法:
			(1.1) 在请求到达处理器(Controller)之前执行
			(1.2) 在请求被处理器(Controller)处理之后执行
			(1.3) 在这次请求的视图渲染完毕之后执行
		(2) 过滤器起作用是在拦截器之前:
			(2.1) 过滤器是在Servlet之前执行的
			(2.2) 拦截器是在DispatcherServlet中被调用的
		(3) 过滤器是属于JavaWeb这个技术栈的,但是拦截器是属于SpringMVC这个技术栈的
		(4) 过滤器能够拦截的最大请求范围是这个项目中的所有请求。而拦截器能够拦截的最大请求范围是DispatcherServlet能够处理的请求范围
	
2. 使用拦截器
	2.1 创建一个类实现HandlerInterceptor接口,并且重写你需要重写的方法
	2.2 在spring-web.xml中配置拦截器的拦截拦截范围
	
3. 拦截器在项目中的使用场景?
	3.1 登录校验、token的验证
	
四、如果不做前后端分离，我们还需要学习哪些内容?
1. 静态资源处理器:
	<mvc:default-servlet-handler />
2. 前端后分离与前后端不分离的优缺点?
	2.1 前后端分离的优点是:可以使用并发能力更强的服务器部署前端项目(静态资源),从而减轻后端服务器的并发压力
	2.2 前后端不分离的优点:没有跨域问题
3. 同步请求和异步请求的优缺点?
	3.1 异步请求的优点:
		(1) 能够做到分块加载数据，提升用户体验
		(2) 异步请求是前后端分离的基础
		(3) 大大减少后端往前端响应的数据的大小
	3.2 同步请求的优点:
		(1) 有一些老项目还在使用这种同步请求的方式
2. 域对象
	2.1 请求域
		(1) 给方法添加HttpServletRequest的参数
		(2)  给方法添加Model 的参数
	2.2 会话域
		(1) 给方法添加HttpSession类型的参数
	2.3 应用域
		(1) 在类中注入ServletContext类型的成员变量
3. jsp
	3.1 在spring-web.xml中配置视图解析器，指定视图前后缀
	3.2 在处理请求的方法中返回要解析的那个视图的逻辑视图
	
4. 请求转发与重定向
	4.1 方法返回: return "redirect:/重定向的路径"
	4.2 方法返回: return "forward:/请求转发的路径"
完成一个简单的同步请求的案例:
1. 客户端发送请求: http://localhost:8080/rest/schedule


